import { BlueHighlight, GreenHighlight } from '@site/src/components/Highlight'; 

# Terminal Shortcuts

To move fast in the bash terminal without reaching for mouse or arrow keys, it is important to learn **GNU readline** shortcuts. GNU readline is what allows for features such as tab completions or scrolling through history with arrow keys in the terminal! By default <GreenHighlight>GNU readline uses Emacs key bindings</GreenHighlight>which is why you see that mentioned in a lot of terminal shortcut cheatsheets.

## Movement

For horizontal movement, start with the following:

- `Ctrl + A` moves to the **beginning** of the line
- `Ctrl + E` moves to the **end** of the line

For character movement:

- `Ctrl + F` moves **forward** one character
- `Ctrl + B` moves **back** one character

For word level movement:

- `Alt + F` moves **forward** to end of next word
- `Alt + B` moves **back** to the start of the current or previous word

:::tip[Trick]

- Think `A` for **start** of alphabet, `E` for **end**.
- Think `F` for forward, `B` for back.

:::

## Killing and Yanking

In Emacs <BlueHighlight>killing</BlueHighlight> is synonymous with cutting, and <BlueHighlight>pasting</BlueHighlight> is synonymous with pasting. Killing something deletes it and sends it to clipboard for pasting.

- `Ctrl + K` kill (cut) **forward** to end of line
- `Ctrl + U` kill (cut) **backward** to start of line

:::tip[Trick]

Often when typing in passwords in the terminal, you mistype. Instead of pressing backspace and trying to delete the typed password to start over (where you don't even know how many characters you need to backspace), you can just delete it with `Ctrl + U`! Then retype your password.

:::

Kill word (very useful for deleting):

- `Alt + D` kill (cut) **forward** to end of current word
- `Ctrl + W` kill (cut) **backward** to the start of current word

Once you'll killed, this adds it to the kill ring. You can yank (paste):

- `Ctrl + Y` yank (paste) from kill ring

If you want to paste something you've killed in the past, you can cycle through the kill ring history by doing `Ctrl + Y` and then `Alt + Y` multiple times to cycle through!
- `Alt + Y` **after `Ctrl + Y`** to cycle through kill ring history

:::note[Detail]

The GNU readline kill ring is local to the process and not shared with other GNU readline instances or the system's clipboard. So you can't easily copy and paste it elsewhere.

:::

## Swap Words

If your cursor is between two words, you can swap them with the command:

- `Alt + T` swap words

## Clear Screen

- `Ctrl + L` clears the screen

## Reverse Search

One of the most useful shortcuts a person first learns is <BlueHighlight>reverse search</BlueHighlight> in history, using `Ctrl + R`. This brings up a prompt where you can search for a previous command by keyword.

- `Ctrl + R` search backward through history

FYI with `fzf` shell integration `Ctrl + R` is even more neat as it will display your command history directly above as you search. Then you can select and paste the desired command from history onto command line.

## Copying Terminal Output

I struggled with figuring out how to copy terminal output to system clipboard (not the GNU Readline buffer) for the longest time. Turns out you just need to drag with your mouse over a selection on the terminal screen and release. It's automatically copied to your system clipboard and you can do `Ctrl + V`.

## Suspend Foreground Process `Ctrl + Z`

I learned by accident when trying to undo inside `nvim`, that `Ctrl + Z` just suspends the current foreground process (takes me out of my editor to shell):

```bash
# Ctrl + Z from inside "nvim ." process
[1]+  Stopped       nvim .
```

To start the process again and resume editing in Neovim, simply do:

```bash
# Resume
fg 1
```

This is all part of [GNU job control](https://www.gnu.org/software/bash/manual/html_node/Job-Control-Basics.html) which involves the ability to selectively stop (suspend) execution of processes and continue (resume) them later. The shell keeps a table of currently executing jobs, which `jobs` will display. Each job has a corresponding job number which `jobs` displays between brackets e.g. `[1]`.

A job started asynchronously might print:

```bash
[1] 23904
```

Which indicates job number 1 with the PID 23904 of the last process in the pipeline associated with this job.

:::info[Key Idea]

In bash you have foreground **(fg)** and background **(bg)** processes. A <BlueHighlight>foreground process</BlueHighlight> occupies the shell window, and blocks subsequent commands until it has finished, for instance the `nvim` text editor program I was using to edit my notes. A <BlueHighlight>background process</BlueHighlight> runs while still allowing the user to interact with the shell.

- Use `Ctrl+Z` to suspend the current foreground process
- Use `jobs` to view active background processes (suspended processes will show up here)
- Use `fg` to put the recently suspended process in the foreground
- Use `bg` to put the recently suspended process in the background
- Use `&` to run a program in the background from the beginning.

:::

Read more in the [job control](00-scripting.mdx#job-control) section of the notes.
